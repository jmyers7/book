Traceback (most recent call last):
  File "/Users/johnmyers/opt/anaconda3/envs/python-2023-08-v2/lib/python3.11/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Users/johnmyers/opt/anaconda3/envs/python-2023-08-v2/lib/python3.11/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/johnmyers/opt/anaconda3/envs/python-2023-08-v2/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 166, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/johnmyers/opt/anaconda3/envs/python-2023-08-v2/lib/python3.11/asyncio/base_events.py", line 653, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/Users/johnmyers/opt/anaconda3/envs/python-2023-08-v2/lib/python3.11/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/Users/johnmyers/opt/anaconda3/envs/python-2023-08-v2/lib/python3.11/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Users/johnmyers/opt/anaconda3/envs/python-2023-08-v2/lib/python3.11/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# For problem 1, define the conditional distribution by subclassing
# `rv_continuous` from SciPy. The conditional density is
# symmetric in x and y, so we only need one implementation
# using "generic" variables `u` and `v`.
def conditional_density(u, v):
    return (2 * u * v + 1 / 2) / (v + 1 / 2)
class ConditionalRV(rv_continuous):
    def __init__(self, v, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.v = v
    def _pdf(self, u):
        return conditional_density(u, self.v)

# For problem 2, the conditional densities are *not*
# symmetric in `x` and `y`, so we need to define two
# conditional distributions.
def conditional_density_YX(y, x):
    return 1 / x
def conditional_density_XY(x, y):
    return (2 * x) / (1 - y**2)
class ConditionalRV_XY(rv_continuous):
    def __init__(self, y, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.y = y
    def _pdf(self, x):
        return conditional_density_XY(x, self.y)
class ConditionalRV_YX(rv_continuous):
    def __init__(self, x, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.x = x
    def _pdf(self, y):
        return conditional_density_YX(y, self.x)

y_list_prob1 = [0.5]
x_list_prob1 = []
y_list_prob2 = [0.5]
x_list_prob2 = []
n = 10000

# Gibbs sampling loop.
np.random.seed(42)
for i in range(n):
    current_y = y_list_prob1[i]
    conditional_rv = ConditionalRV(a=0, b=1, v=current_y)
    sampled_x = conditional_rv.rvs()
    conditional_rv = ConditionalRV(a=0, b=1, v=sampled_x)
    sampled_y = conditional_rv.rvs()
    y_list_prob1.append(sampled_y)
    x_list_prob1.append(sampled_x)

    current_y = y_list_prob2[i]
    conditional_rv_XY = ConditionalRV_XY(a=current_y, b=1, y=current_y)
    sampled_x = conditional_rv_XY.rvs()
    conditional_rv_YX = ConditionalRV_YX(a=0, b=sampled_x, x=sampled_x)
    sampled_y = conditional_rv_YX.rvs()
    y_list_prob2.append(sampled_y)
    x_list_prob2.append(sampled_x)

# Ditch initial values, discard burn-ins.
_ = y_list_prob1.pop(0)
x_list_prob1 = x_list_prob1[2000:]
y_list_prob1 = y_list_prob1[2000:]
_ = y_list_prob2.pop(0)
x_list_prob2 = x_list_prob2[2000:]
y_list_prob2 = y_list_prob2[2000:]

# Scatter plot for the centered distributions.
_, axes = plt.subplots(ncols=2, figsize=(10, 5))

sns.scatterplot(x=x_list_prob1 - np.mean(x_list_prob1),
                y=y_list_prob1 - np.mean(y_list_prob1),
                alpha=0.5,
                ax=axes[0])
sns.scatterplot(x=x_list_prob2 - np.mean(x_list_prob2),
                y=y_list_prob2 - np.mean(y_list_prob2),
                alpha=0.5,
                ax=axes[1])
axes[0].set_xlabel('x')
axes[0].set_ylabel('y')
axes[0].set_xlim(-0.7, 0.7)
axes[0].set_ylim(-0.7, 0.7)
axes[0].axhline(0, color='black', linewidth=0.5)
axes[0].axvline(0, color='black', linewidth=0.5)
axes[0].set_title('simulated distribution for problem 1')
axes[1].set_xlabel('x')
axes[1].set_ylabel('y')
axes[1].set_xlim(-0.7, 0.7)
axes[1].set_ylim(-0.7, 0.7)
axes[1].axhline(0, color='black', linewidth=0.5)
axes[1].axvline(0, color='black', linewidth=0.5)
axes[1].set_title('simulated distribution for problem 2')
plt.tight_layout()
------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mNameError[0m                                 Traceback (most recent call last)
Cell [0;32mIn[6], line 7[0m
[1;32m      5[0m [38;5;28;01mdef[39;00m [38;5;21mconditional_density[39m(u, v):
[1;32m      6[0m     [38;5;28;01mreturn[39;00m ([38;5;241m2[39m [38;5;241m*[39m u [38;5;241m*[39m v [38;5;241m+[39m [38;5;241m1[39m [38;5;241m/[39m [38;5;241m2[39m) [38;5;241m/[39m (v [38;5;241m+[39m [38;5;241m1[39m [38;5;241m/[39m [38;5;241m2[39m)
[0;32m----> 7[0m [38;5;28;01mclass[39;00m [38;5;21;01mConditionalRV[39;00m([43mrv_continuous[49m):
[1;32m      8[0m     [38;5;28;01mdef[39;00m [38;5;21m__init__[39m([38;5;28mself[39m, v, [38;5;241m*[39margs, [38;5;241m*[39m[38;5;241m*[39mkwargs):
[1;32m      9[0m         [38;5;28msuper[39m()[38;5;241m.[39m[38;5;21m__init__[39m([38;5;241m*[39margs, [38;5;241m*[39m[38;5;241m*[39mkwargs)

[0;31mNameError[0m: name 'rv_continuous' is not defined


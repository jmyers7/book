Traceback (most recent call last):
  File "/Users/johnmyers/miniconda3/envs/python-2023-12/lib/python3.10/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Users/johnmyers/miniconda3/envs/python-2023-12/lib/python3.10/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/Users/johnmyers/miniconda3/envs/python-2023-12/lib/python3.10/site-packages/jupyter_core/utils/__init__.py", line 173, in wrapped
    return loop.run_until_complete(inner)
  File "/Users/johnmyers/miniconda3/envs/python-2023-12/lib/python3.10/asyncio/base_events.py", line 649, in run_until_complete
    return future.result()
  File "/Users/johnmyers/miniconda3/envs/python-2023-12/lib/python3.10/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/Users/johnmyers/miniconda3/envs/python-2023-12/lib/python3.10/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Users/johnmyers/miniconda3/envs/python-2023-12/lib/python3.10/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# import logistic regression model from scikit-learn
from sklearn.linear_model import LogisticRegression()

# pull out the 'x' columns and the 'y' column, and convert to numpy arrays
x = df[['x_1', 'x_2']].to_numpy()
y = df['y'].to_numpy()

# instantiate a logistic regression model
lr = LogisticRegression

# train the model
lr.fit(X=x, y=y)

# begin code to plot decision boundary. define resolution of grid.
resolution = 1000

# define grid
x_1 = np.linspace(-1, 3, resolution)
x_2 = np.linspace(-30, 40, resolution)
grid_1, grid_2 = np.meshgrid(x_1, x_2)
grid = np.column_stack((grid_1.reshape((resolution ** 2, -1)), grid_2.reshape((resolution ** 2, -1))))

# apply the fitted model to the grid
z = lr.predict(grid)

# plot the decision boundary and colors
z = z.reshape((resolution, resolution))
cmap = clr.LinearSegmentedColormap.from_list('custom', [blue, magenta], N=2)
plt.contourf(grid_1, grid_2, z, cmap=cmap, alpha=0.45)
plt.contour(grid_1, grid_2, z)

# plot the data
g = sns.scatterplot(data=df, x='x_1', y='x_2', hue='y')

# change the default seaborn legend
g.legend_.set_title(None)
new_labels = ['class 0', 'class 1']
for t, l in zip(g.legend_.texts, new_labels):
    t.set_text(l)

plt.xlabel('$x_1$')
plt.ylabel('$x_2$')
plt.xlim(-1.1, 3.1)
plt.ylim(-32, 42)
plt.gcf().set_size_inches(w=5, h=5)
plt.tight_layout()
------------------


[0;36m  Cell [0;32mIn[6], line 2[0;36m[0m
[0;31m    from sklearn.linear_model import LogisticRegression()[0m
[0m                                                       ^[0m
[0;31mSyntaxError[0m[0;31m:[0m invalid syntax


